component ioMachine "IO machine test";

description 
"""
Machine controller

""";
 
author "";

license "GPL";

option singleton yes;

// // inputs

// EL1018 - slave
pin in bit 			liftRamUp;
pin in bit 			liftRamDown;
pin in bit 			spireEngageIn;
pin in bit 			spireEngageOut;
pin in bit 			liftFrameLatchEngaged;
pin in bit 			liftFrameLatchDisengaged;
pin in bit 			liftFrameMated;
pin in bit 			incomingAirOK;

// EL1018 - slave
pin in bit          startButton;
pin in bit          stopButton;
pin in bit          cycleStartButton;
pin in bit          lubricantLow;
pin in bit          pressureFilterBlocked;
pin in bit          eStop;
pin in bit          lightCurtainInput;
pin in bit          inverterFault;

// // outputs

// EL2008 - slave
pin out bit			lubricationPump;
pin out bit			inverterEnable;
pin out bit			inverterSpeedBit1;
pin out bit			inverterSpeedBit2;
pin out bit			hydraulicLoad;

// EL2024 - slave
pin out bit 		partLiftRam;
pin out bit 		spireEngage;
pin out bit 		latchLiftFrame;
pin out bit 		spireLubeAirAssist;


// io for positions
pin out float 		oAxisCommand;
pin in float		oAxisPosition;
pin in float		oAxisPositionRaw;
pin out bit			oAxisEnable;  //enable analog out
pin out bit			oAxisEnablePid; //

pin out float 		iAxisCommand;
pin in float		iAxisPosition;
pin in float		iAxisPositionRaw;
pin out bit			iAxisEnable;
pin out bit			iAxisEnablePid; //



// manual and calibration

pin out float		iAxisManualCommand;
pin out float		oAxisManualCommand;

pin in bit			manualTogglePartUp;
pin in bit			manualToggleLiftCatch;
pin in bit			manualToggleSpireEngage;


pin in bit			hydraulicsOff;
pin in bit			hydraulicSpeed1;
pin in bit			hydraulicSpeed2;
pin in bit			hydraulicSpeed3;
pin in bit			manualHydraulicLoad;

pin out signed		hydraulicSpeed;
pin io signed		requestHydraulicSpeed;


pin in float		iJogSpeed;
pin in float		oJogSpeed;
pin in bit			iJogPlus;
pin in bit			iJogMinus;
pin in bit 			oJogPlus;
pin in bit			oJogMinus;




// hmi etc
pin in bit          startEdge;

pin in float        cycleTimeOut;
pin in float        readyTimeOut;




pin out float       lastCycle;

// pin and variables
pin out u32         currentState;          // for display in hmi
pin out unsigned	currentOperation;		// operation number in motion starting 0

pin in bit          requestManual;
pin io signed		requestState;
pin out bit         stateLocked;


pin out unsigned    clampTimerRemain;
pin out float       clampTimerRemainSeconds;

//pin out float       spindleTimerRemain;

pin out unsigned    cycleTimerRemain;
pin out unsigned    readyTimerRemain;
pin out float       readyTimerRemainSeconds;

// parameters
pin out signed		lubricationCounter;
param rw unsigned	lubricateCycleCounter;

/*
 * possibility of having these in a sep. module
 * but then more hal wiring mucking about
 * so they are in here for now....
 */

//position for tool release
pin in float		oAxisToolReleasePosition;
// position for part lift clearance;
pin in float 		oAxisPartLiftPosition;
pin in float		oAxisLubricationPosition;

// operation type -1 no op; 0 I op; 1 O op
pin in signed		operationType-#[10];
pin in float		position-#[10];


//calibration data
// this data is from the calibration state...
// this can be loaded from the hmi and also
// configured from the calibration_state

//pin out signed 		calibrationTimer;
pin out float		calibrationTimerSeconds;
pin out signed		calibrationCounter;

pin io float		iAxisOffset;
pin io float		iAxisScale;
pin io float		oAxisOffset;
pin io float		oAxisScale;

pin out float		iTop;
pin out float		iBottom;
pin out float		oTop;
pin out float		oBottom;


// Global Variables
variable double totalnsec;
variable int old_start;

//variable double clampTimerRemain;
//variable double spindleTimerRemain;

variable long gPeriod;


function _;

;;

long long calibrationTimer;
long long hydraulicTimer;

#include "rtapi_math.h"

enum states {   STATE_INITIAL = 0,
				STATE_STANDBY,
				STATE_PREPAREREADY,
				STATE_NOTOOL,
                STATE_READY,
                STATE_PREPARETOOLRELEASE,		//5
                STATE_TOOLRELEASED,
                STATE_LOWERPART,
                STATE_MOTION,
                STATE_FINALISE,
                STATE_RAISEPART,  				//10
                STATE_MANUAL,
                STATE_CYCLE_ABORT,
                STATE_LUBRICANT_LOW,
                STATE_NO_AIR,
                STATE_FILTER_BLOCKED,   		//15
                STATE_INVERTER_FAULT,
                STATE_ESTOP,
                STATE_CALIBRATE,				//18
                MAX_STATES };

//enum hydarulicSpeed { 	HYDRAULIC_OFF,
//						HYDRAULIC_1,
//					}


//if we have changed state
bool state_entry = true;

// these are substate variables used in different states.
int toolChangeCounter = -1;
int prepareReadyCounter = -1;


// change state in the state machine
static void change_state(struct __comp_state *__comp_inst, int new_state){
    state_entry = true;
    currentState = new_state;
}

// utility funcs...
//static float to_nanoseconds(struct __comp_state *__comp_inst, float seconds){
static long long to_nanoseconds(struct __comp_state *__comp_inst, float seconds){
    return (long long)(seconds * 1000000000.0);
}

static float to_seconds(struct __comp_state *__comp_inst, long long nanoseconds){
    return ((float)nanoseconds) * 0.000000001;
}

static void hydraulic_state(struct __comp_state *__comp_inst){

	if (hydraulicTimer > 0)
		hydraulicTimer -= gPeriod;

	// requested faster speed
	if (requestHydraulicSpeed > hydraulicSpeed && hydraulicTimer <= 0){
		hydraulicSpeed++;
		hydraulicTimer = to_nanoseconds(__comp_inst, 0.5);
	}

	if (requestHydraulicSpeed < hydraulicSpeed)
		hydraulicSpeed--;

	switch (hydraulicSpeed){
	case 0:
		inverterEnable = false;
		inverterSpeedBit1 = false;
		inverterSpeedBit2 = false;
		hydraulicLoad = false;
		break;
	case 1:
		inverterEnable = true;
		inverterSpeedBit1 = true;
		inverterSpeedBit2 = false;
		hydraulicLoad = false;
		break;
	case 2:
		inverterEnable = true;
		inverterSpeedBit1 = false;
		inverterSpeedBit2 = true;
		break;
	case 3:
		inverterEnable = true;
		inverterSpeedBit1 = true;
		inverterSpeedBit2 = true;
		break;
	}
}

static void set_hydraulic_load(struct __comp_state *__comp_inst, bool on){
	if (on && hydraulicSpeed > 1){
		hydraulicLoad = true;
	} else {
		hydraulicLoad = true;
	}
}

static void set_hydraulic_speed(struct __comp_state *__comp_inst, int speed){

	if (speed > 3)
		speed = 3;

	requestHydraulicSpeed = speed;

//	switch (speed){
//	case 0:
//		inverterEnable = false;
//		inverterSpeedBit1 = false;
//		inverterSpeedBit2 = false;
//		break;
//	case 1:
//		inverterEnable = true;
//		inverterSpeedBit1 = true;
//		inverterSpeedBit2 = false;
//		break;
//	case 2:
//		inverterEnable = true;
//		inverterSpeedBit1 = false;
//		inverterSpeedBit2 = true;
//		break;
//	case 3:
//		inverterEnable = true;
//		inverterSpeedBit1 = true;
//		inverterSpeedBit2 = true;
//		break;
//	}
}

static void request_hydraulic_speed(struct __comp_state *__comp_inst, int speed){

}

/*
 *  State Machine Functions
 */

static void state_estop(struct __comp_state *__comp_inst){
	if (state_entry) {
		state_entry = false;
	}
	if (!eStop)
		change_state(__comp_inst, STATE_STANDBY);
}

static void state_initial(struct __comp_state *__comp_inst){
	if (state_entry){
		state_entry = false;
	}

	change_state(__comp_inst, STATE_STANDBY);

}

static void state_standby(struct __comp_state *__comp_inst){
    //rtapi_print("in standby\n");

    if (state_entry) {
        state_entry = false;


        // this will always be true except for tool change
        // setting these to true now... but they should already on here
        // TODO: move these to prepare_ready
        spireEngage = true;
        latchLiftFrame = true;

        set_hydraulic_speed(__comp_inst, 0);
    }


    if (requestState == STATE_CALIBRATE){
    	change_state(__comp_inst, STATE_CALIBRATE);
    	requestState = -1;
    }

    if (requestManual)
    	change_state(__comp_inst, STATE_MANUAL);

    if (startButton) {
    	//change_state(__comp_inst, STATE_READY);
    	change_state(__comp_inst, STATE_PREPAREREADY);
    }
}


static void state_prepareready(struct __comp_state *__comp_inst){
    if (state_entry){
        state_entry = false;
        prepareReadyCounter = 0;
        set_hydraulic_speed(__comp_inst, 1);
    }

    if (!liftFrameMated){
    	change_state(__comp_inst, STATE_NOTOOL);
    }

    switch (prepareReadyCounter){
    case 0:
    	// wait for light curtain to become active
    	if (lightCurtainInput)
    		prepareReadyCounter++;
    	break;
    case 1:
    	set_hydraulic_speed(__comp_inst, 2);
    	if (hydraulicSpeed == 2){
    		prepareReadyCounter++;
    		set_hydraulic_load(__comp_inst, true);
    	}
    	break;
    case 2:
    	// move the head up (so the tool lift can move into place)
    	//oAxisPosition = 10.0f;
    	//oAxisCommand = 10.0;

    	// TODO: motion
    	if (true) {
    		prepareReadyCounter++;
    		// start the ram lifting
    		partLiftRam = true;
    		// TODO: turn off hyd.
    		set_hydraulic_speed(__comp_inst, 1);
    		set_hydraulic_load(__comp_inst, false);
    	}
    	break;
    case 3:
    	// filter the listRamUp for 100ms
    	if (liftRamUp){
    		prepareReadyCounter++;
    		cycleTimerRemain = to_nanoseconds(__comp_inst, 0.1f);
    	}
    	break;
    case 4:
    	if (!liftRamUp)
    		prepareReadyCounter--;

    	cycleTimerRemain -= gPeriod; // decrement timer

    	if (cycleTimerRemain <= 0.0)
    		change_state(__comp_inst, STATE_READY);
    }

}



static void state_ready(struct __comp_state *__comp_inst){
    if (state_entry){
        state_entry = false;

//        inverterEnable = true;
//        inverterSpeedBit1 = false;
//        inverterSpeedBit2 = false;
//        hydraulicLoad = false;


        readyTimerRemain = to_nanoseconds(__comp_inst, readyTimeOut);

        // set a default if 0
        if (readyTimerRemain <= 0.0)
            readyTimerRemain = to_nanoseconds(__comp_inst, 300); // 5 minutes
    }

    if (readyTimerRemain <= 0.0)
        change_state(__comp_inst, STATE_STANDBY);

    if (stopButton)
        change_state(__comp_inst, STATE_STANDBY);

    if (requestManual)
        change_state(__comp_inst, STATE_MANUAL);

    if (eStop)
        change_state(__comp_inst, STATE_STANDBY);

    readyTimerRemain -= gPeriod; //decrement timer by period
    
    if (cycleStartButton){

    	change_state(__comp_inst, STATE_LOWERPART);

        //change_state(__comp_inst, STATE_CLOSEVICE);
        stateLocked = true;
    }
}

static void state_preparetoolrelease(struct __comp_state *__comp_inst){
	if (state_entry){
		state_entry = false;
		toolChangeCounter = 0;
	}

	switch (toolChangeCounter){
	case 0:
		// TODO: Here we need to do motion so the axes
		// are in the correct position prior to tool
		// change
		toolChangeCounter++;
		break;

	case 1:
		// move the spire latch out....
		spireEngage = false;
		if (spireEngageOut)
			toolChangeCounter++;
		break;

	case 2:
		latchLiftFrame = false;
		if (liftFrameLatchDisengaged)
			toolChangeCounter++;
		break;
	case 3:
		change_state(__comp_inst, STATE_TOOLRELEASED);
		break;
	}
}

static void state_toolreleased(struct __comp_state *__comp_inst){
	if (state_entry){
		state_entry = false;
	}
	if (!liftFrameMated)
	{
		change_state(__comp_inst, STATE_NOTOOL);
	}
}

static void state_lowerpart(struct __comp_state *__comp_inst){

    if (state_entry){
        state_entry = false;
        partLiftRam = false;
        set_hydraulic_speed(__comp_inst, 2);
    }

    if (liftRamDown && hydraulicSpeed == 2){
        change_state(__comp_inst, STATE_MOTION);
    }
}

static void state_raisepart(struct __comp_state *__comp_inst){

    if (state_entry){
        state_entry = false;
        partLiftRam = true;

    }

    // TODO: Time out

    if (liftRamUp){
        change_state(__comp_inst, STATE_READY);
        stateLocked = false;
    }
}


static void state_motion(struct __comp_state *__comp_inst){

    bool exit = false;
    float currentTarget = 0.0;
    float currentError = 0.0;
    float currentPosition = 0.0;
    static bool newTarget = true;

    if (state_entry){
        state_entry = false;
        // with a 25 second time-out
        cycleTimerRemain = to_nanoseconds(__comp_inst, cycleTimeOut);

        // set a default if 0
        if (cycleTimerRemain <= 0.0)
            cycleTimerRemain = to_nanoseconds(__comp_inst, 60.0);

        currentOperation = 0;
        newTarget = true;
        iAxisEnablePid = true;
        oAxisEnablePid = true;
    }

    // decrement timer
    cycleTimerRemain -= gPeriod;


    if (newTarget)
    {
		switch (operationType(currentOperation)){

		case 0:
			// I operation
			iAxisEnable = true;
			//hydraulicLoad = true;
			iAxisCommand = position(currentOperation);
			currentPosition = iAxisPosition;
			break;
		case 1:
			// O operation
			oAxisEnable = true;
			//hydraulicLoad = true;
			oAxisCommand = position(currentOperation);
			currentPosition = oAxisPosition;
			break;
		case -1:
			//last operation
			//exit = true;


			break;
		}

		currentTarget = position(currentOperation);
		newTarget = false;
    }


    currentError = abs(currentPosition - currentTarget);

    if (currentError < 0.01){ // TODO: deadband could param'd
    	// in position next
    	currentOperation++;
        iAxisEnable = false;
        oAxisEnable = false;
        hydraulicLoad = false;
        newTarget = true;
    }

    // cycle did not complete in time
    if (cycleTimerRemain <= 0.0){
        //change_state(__comp_inst, STATE_FINALISE);
    	exit = true;
    }

    // cycle aborted
    if (stopButton){
    	//change_state(__comp_inst, STATE_FINALISE);
    	exit = true;
    }

    if (exit){
    	iAxisEnable = false;
    	oAxisEnable = false;
    	iAxisEnablePid = false;
    	oAxisEnablePid = false;
    	change_state(__comp_inst, STATE_FINALISE);

    }

}

static void state_finalise(struct __comp_state *__comp_inst){
	if (state_entry){
		state_entry = false;
	}

	change_state(__comp_inst, STATE_RAISEPART);
}

static void state_calibrate(struct __comp_state *__comp_inst){

	bool exit = false;

	if (state_entry){
		state_entry = false;
		//hydraulicLoad = true;
		iTop = 0.0;
		iBottom = 0.0;
		oTop = 0.0;
		oBottom = 0.0;

		calibrationTimer = to_nanoseconds(__comp_inst, 1.0);
		calibrationCounter = 0;

		set_hydraulic_speed(__comp_inst, 2);
		stateLocked = true;
	}

	calibrationTimer -= gPeriod;


	if (calibrationTimer <= 0){

		switch (calibrationCounter){
		case 0:
			hydraulicLoad = true;
			calibrationTimer = to_nanoseconds(__comp_inst, 0.25);
			break;
		case 1:
			calibrationTimer = to_nanoseconds(__comp_inst, 7.0);
			oAxisManualCommand = 1.0;
			iAxisManualCommand = 1.0;
			iAxisEnable = true;
			oAxisEnable = true;
			break;
		case 2:
			calibrationTimer = to_nanoseconds(__comp_inst, 7.0);
			iTop = iAxisPositionRaw;
			oTop = oAxisPositionRaw;
			oAxisManualCommand = -1.0;
			iAxisManualCommand = -1.0;
			break;
		case 3:
			iBottom = iAxisPositionRaw;
			oBottom = oAxisPositionRaw;

			oAxisManualCommand = 0.0;
			iAxisManualCommand = 0.0;

			iAxisScale = abs(iTop-iBottom)/85.0;
			iAxisScale *= 0.10510423526567646251;
			iAxisOffset = iTop * iAxisScale;

			oAxisScale = abs(oTop-oBottom)/80.0;
			oAxisScale *= 0.12278456090290459113;
			oAxisOffset = oTop * oAxisScale;

			exit = true;

			break;
		}
		calibrationCounter++;
	}

	if (exit){
		stateLocked = false;
		hydraulicLoad = false;
		iAxisEnable = false;
		oAxisEnable = false;
		set_hydraulic_speed(__comp_inst, 0);
		change_state(__comp_inst, STATE_STANDBY);
	}
}

static void state_manual(struct __comp_state *__comp_inst){
    bool exit = false;

    if (state_entry){
        state_entry = false;
        //enableManual = 1;
        inverterEnable = false;
    }

    if (startButton && !eStop){
        //hydraulicMotor = 1;
        return;
    } else if (stopButton){
        //hydraulicMotor = 0;
        return;
    } else if (eStop) {
        //hydraulicMotor = 0;
        return;
    }

    /*
     * Jogging using the following pins
    pin in float		iJogSpeed;
    pin in float		oJogSpeed;
    pin in bit			iJogPlus;
    pin in bit			iJogMinus;
    pin in bit 			oJogPlus;
    pin in bit			oJogMinus;
    */

    if (iJogPlus){
    	iAxisEnable = true;
    	iAxisManualCommand = iJogSpeed;
    } else if (iJogMinus) {
    	iAxisEnable = true;
    	iAxisManualCommand = -iJogSpeed;
    } else {
    	iAxisEnable = false;
    }

    if (oJogPlus){
    	oAxisEnable = true;
    	oAxisManualCommand = oJogSpeed;
    } else if (oJogMinus) {
    	oAxisEnable = true;
    	oAxisManualCommand = -oJogSpeed;
    } else {
    	oAxisEnable = false;
    }

    /*
    pin in bit			manualTogglePartUp;
    pin in bit			manualToggleLiftCatch;
    pin in bit			manualToggleSpireEngage;
    */

    if (manualTogglePartUp){
    	// TODO: if outer-ring is not at top
    	partLiftRam = true;
    } else {
    	partLiftRam = false;
    }

    if (manualToggleSpireEngage)
    	spireEngage = true;
    else
    	spireEngage = false;

    if (manualToggleLiftCatch){
    	// TODO: check part face mated liftFrameMated
    	latchLiftFrame = true;
    } else {
    	latchLiftFrame = false;
    }

    /*
    pin in bit			hydraulicsOff;
    pin in bit			hydraulicSpeed1;
    pin in bit			hydraulicSpeed2;
    pin in bit			hydraulicSpeed3;
    */
    if (manualHydraulicLoad && !hydraulicsOff) {
    	hydraulicLoad = true;
    } else {
    	hydraulicLoad = false;
    }


    if (hydraulicsOff) {
    	set_hydraulic_speed(__comp_inst, 0);
    	hydraulicLoad = false;
//    	inverterEnable = false;
//    	inverterSpeedBit1 = false;
//    	inverterSpeedBit2 = false;
    }

    if (hydraulicSpeed1) {
    	set_hydraulic_speed(__comp_inst, 1);
//    	inverterEnable = true;
//    	inverterSpeedBit1 = true;
//    	inverterSpeedBit2 = false;
    }
    if (hydraulicSpeed2) {
    	set_hydraulic_speed(__comp_inst, 2);
//    	inverterEnable = true;
//    	inverterSpeedBit1 = false;
//    	inverterSpeedBit2 = true;
    }
    if (hydraulicSpeed3) {
    	set_hydraulic_speed(__comp_inst, 3);
//    	inverterEnable = true;
//    	inverterSpeedBit1 = true;
//    	inverterSpeedBit2 = true;
    }

    if (!requestManual){
        exit = true;
    }

    if (exit){
    	if (true)
            change_state(__comp_inst, STATE_READY);
        else
            change_state(__comp_inst, STATE_STANDBY);
    }
}



//update timer in seconds outputs
static void update_timer_outs(struct __comp_state *__comp_inst){
    clampTimerRemainSeconds = to_seconds(__comp_inst, clampTimerRemain);
    readyTimerRemainSeconds = to_seconds(__comp_inst, readyTimerRemain);
    calibrationTimerSeconds = to_seconds(__comp_inst, calibrationTimer);
}

FUNCTION(_) {

	//__comp_state *inst = __comp_inst;
    update_timer_outs(__comp_inst);

    // output last period to pin
    lastCycle = period - gPeriod;
    // store the current nanosecond period offset
    gPeriod = period;

    /*
     * always processed system checks
     */

    //if (lubricantLow && !ignoreLubricant){

//    if (lubricantLow){
//    	//chnage state to
//    	change_state(__comp_inst, STATE_LUBRICANT_LOW);
//    }
//
//    if (!incomingAirOK){
//    	change_state(__comp_inst, STATE_NO_AIR);
//    }
//
//    if (pressureFilterBlocked){
//    	change_state(__comp_inst, STATE_FILTER_BLOCKED);
//    }
//
//    if (inverterFault){
//    	change_state(__comp_inst, STATE_INVERTER_FAULT);
//    }
//
//    if (eStop)
//    	change_state(__comp_inst, STATE_ESTOP);

    // process hydraulics
    hydraulic_state(__comp_inst);
    
    // switch on state
    switch (currentState)
    {
    case STATE_INITIAL:
    	state_initial(__comp_inst);
    	break;
    case STATE_STANDBY:
    	state_standby(__comp_inst);
    	break;
    case STATE_PREPAREREADY:
    	state_prepareready(__comp_inst);
    	break;
    case STATE_READY:
    	state_ready(__comp_inst);
    	break;
    case STATE_PREPARETOOLRELEASE:
    	state_preparetoolrelease(__comp_inst);
    	break;
    case STATE_LOWERPART:
    	state_lowerpart(__comp_inst);
    	break;
    case STATE_MOTION:
    	state_motion(__comp_inst);
    	break;
    case STATE_FINALISE:
    	state_finalise(__comp_inst);
    	break;
    case STATE_RAISEPART:
    	state_raisepart(__comp_inst);
    	break;
    case STATE_MANUAL:
    	state_manual(__comp_inst);
    	break;
    case STATE_ESTOP:
    	state_estop(__comp_inst);
    	break;
    case STATE_CALIBRATE:
    	state_calibrate(__comp_inst);
    	break;
    case MAX_STATES:
    	state_ready(__comp_inst);
    	break;

    }
}

